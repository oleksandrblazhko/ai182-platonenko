### Тестування для MySQL
#### Резюме
Уразливості SQL Injection виникають щоразу, коли вхідні дані використовуються для побудови SQL-запиту без відповідних обмежень або санітарної обробки. Використання динамічного SQL (побудова SQL-запитів шляхом конкатенації рядків) відкриває двері для цих вразливостей. SQL-ін’єкція дозволяє зловмиснику отримати доступ до серверів SQL. Це дозволяє виконувати код SQL під привілеями користувача, який використовується для підключення до бази даних.

Сервер MySQL має кілька особливостей, тому деякі експлойти потрібно спеціально налаштовувати для цієї програми. Це тема цього розділу.

### Як тестувати
Коли в програмі, що підтримується базою даних MySQL, виявляється вразливість SQL-ін’єкції, існує низка атак, які можуть бути здійснені залежно від версії MySQL і привілеїв користувача на СУБД.

MySQL має принаймні чотири версії, які використовуються у виробництві в усьому світі, 3.23.x, 4.0.x, 4.1.x і 5.0.x. Кожна версія має набір функцій, пропорційний номеру версії.

- From Version 4.0: UNION
- From Version 4.1: Subqueries
- From Version 5.0: Stored procedures, Stored functions and the view named INFORMATION_SCHEMA
- From Version 5.0.2: Triggers

Слід зазначити, що для версій MySQL до 4.0.x можна було використовувати лише логічні атаки або атаки на сліпу ін’єкцію на основі часу, оскільки функція підзапитів або оператори UNION не були реалізовані.

Відтепер ми будемо припускати, що існує класична вразливість SQL-ін’єкції, яка може бути викликана запитом, подібним до описаного в розділі «Тестування SQL-ін’єкції».

`http://www.example.com/page.php?id=2`

#### Проблема одинарних лапок
Перш ніж скористатися можливостями MySQL, слід розглянути, як рядки можуть бути представлені в операторі, оскільки веб-додатки часто не беруться в одинарні лапки.

Екранування лапок MySQL таке:

`'A string with \'quotes\''`

Тобто MySQL інтерпретує екрановані апостроф \' як символи, а не як метасимволи.

Отже, якщо програма для належної роботи потребує використання постійних рядків, слід розрізняти два випадки:

1. Веб-програма не використовує одинарні лапки ' => \'
2. Веб-програма не використовує одинарні лапки ' => '
У MySQL існує стандартний спосіб обійти потребу в одинарних лапках, маючи постійний рядок для оголошення без необхідності в одинарних лапках.

Припустімо, ми хочемо знати значення поля з іменем password у записі з такою умовою:

- password like 'A%'
- The ASCII values in a concatenated hex: password LIKE 0x4125
- The char() function: password LIKE CHAR(65,37)

#### Кілька змішаних запитів
Конектори бібліотек MySQL не підтримують кілька запитів, розділених символом ; тому немає способу ввести кілька неоднорідних команд SQL в одну вразливість, як у Microsoft SQL Server.

Наприклад, наступна ін’єкція призведе до помилки:

`1 ; update tablename set code='javascript code' where 1 --`

### Збір інформації
#### Відбитки пальців MySQL
Звичайно, перше, що потрібно знати, це наявність СУБД MySQL як внутрішньої бази даних. Сервер MySQL має функцію, яка використовується для того, щоб інші СУБД ігнорували положення на діалекті MySQL. Коли блок коментарів '/**/' містить знак оклику '/*! sql here*/' він інтерпретується MySQL і розглядається як звичайний блок коментарів іншими СУБД, як пояснюється в посібнику MySQL.

Приклад:
`1 /*! and 1=0 */`

> Якщо MySQL присутній, речення всередині блоку коментарів буде інтерпретовано.

###Версія
#### Є три способи отримати цю інформацію:

- За допомогою глобальної змінної @@version
- За допомогою функції VERSION()
- Використовуючи відбитки коментарів із номером версії /*!40110 і 1=0*/

`if(version >= 4.1.10)
   add 'and 1=0' to the query.`
   
Вони еквівалентні, оскільки результат однаковий.

Ін'єкція смуги:
`1 AND 1=0 UNION SELECT @@version /*`

Інференційна ін'єкція:

`1 AND @@version like '4.0%'`

Відповідь містила б такі рядки:

`5.0.22-log`

#### Вхід користувача
Існує два типи користувачів, на яких покладається MySQL Server.

- USER(): користувач, підключений до сервера MySQL.
- CURRENT_USER(): внутрішній користувач, який виконує запит.

Між 1 і 2 є певна різниця. Головна полягає в тому, що анонімний користувач може підключитися (якщо це дозволено) з будь-яким іменем, але внутрішній користувач MySQL — це порожнє ім’я (‘’). Інша відмінність полягає в тому, що збережена процедура або збережена функція виконуються як користувач-творець, якщо вони не оголошені в іншому місці. Це можна дізнатися за допомогою CURRENT_USER.

Ін'єкція смуги:

`1 AND 1=0 UNION SELECT USER()`

Інференційна ін'єкція:

`1 AND USER() like 'root%'`

Відповідь містила б такі рядки:

`user@hostname`

#### Назва бази даних, що використовується
Існує рідна функція DATABASE()

Ін'єкція смуги:

`1 AND 1=0 UNION SELECT DATABASE()`

Інференційна ін'єкція:

`1 AND DATABASE() like 'db%'`

#### INFORMATION_SCHEMA
З MySQL 5.0 було створено представлення під назвою INFORMATION_SCHEMA. Це дозволяє нам отримати всю інформацію про бази даних, таблиці та стовпці, а також про процедури та функції.

| Tables_in_INFORMATION_SCHEMA | 	DESCRIPTION | 
| --- | --- |
| SCHEMATA |	All databases the user has (at least) SELECT_priv |
| SCHEMA_PRIVILEGES |	The privileges the user has for each DB |
| TABLES	All | tables the user has (at least) SELECT_priv |
| TABLE_PRIVILEGES | The privileges the user has for each table |
| COLUMNS	All | columns the user has (at least) SELECT_priv |
| COLUMN_PRIVILEGES	| The privileges the user has for each column |
| VIEWS	All | columns the user has (at least) SELECT_priv |
| ROUTINES |	Procedures and functions (needs EXECUTE_priv) |
| TRIGGERS | Triggers (needs INSERT_priv) |
| USER_PRIVILEGES	| Privileges connected User has |

Усю цю інформацію можна отримати за допомогою відомих методів, як описано в розділі «Впровадження SQL».

### Вектори атак
#### Записати у файл
Якщо підключений користувач має привілеї FILE і одинарні лапки не екрануються, пропозицію into outfile можна використовувати для експорту результатів запиту у файл.

`Select * from table into outfile '/tmp/file'`

> Примітка: немає способу обійти одинарні лапки навколо назви файлу. Отже, якщо є певне очищення одинарних лапок, як-от escape \', не буде можливості використати пропозицію into outfile.

Цей вид атаки можна використовувати як позасмугову техніку для отримання інформації про результати запиту або для запису файлу, який можна виконати в каталозі веб-сервера.

Приклад:

`1 limit 1 into outfile '/var/www/root/test.jsp' FIELDS ENCLOSED BY '//'  LINES TERMINATED BY '\n<%jsp code here%>';`

> Результати зберігаються у файлі з правами rw-rw-rw, який належить користувачу та групі MySQL.
> Де /var/www/root/test.jsp міститиме:
> //значення полів// <%jsp код тут%>

#### Читання з файлу
load_file — це рідна функція, яка може читати файл, коли це дозволено дозволами файлової системи. Якщо підключений користувач має привілеї FILE, його можна використовувати для отримання вмісту файлів. Одинарні лапки можна обійти, використовуючи описані раніше прийоми.
`load_file('ім'я файлу')`

> Весь файл буде доступний для експорту за допомогою стандартних методів.

### Стандартна атака SQL Injection
У стандартній SQL-ін’єкції результати можуть відображатися безпосередньо на сторінці як звичайний вихід або як помилка MySQL. Використовуючи вже згадані атаки SQL Injection і вже описані функції MySQL, пряме SQL ін’єкцію можна легко здійснити на глибині рівня, що залежить головним чином від версії MySQL, з якою стикається пентестер.

Хороша атака полягає в тому, щоб знати результати, змушуючи функцію/процедуру або сам сервер видавати помилку. Список помилок, які викидає MySQL і, зокрема, рідні функції, можна знайти в посібнику MySQL.

### Позадіапазонне впровадження SQL
Позасмугове впровадження можна здійснити за допомогою пропозиції into outfile.

### Сліпе впровадження SQL
Для сліпого SQL-ін’єкції існує набір корисних функцій, які надаються сервером MySQL.

+ Довжина рядка:
  * ДОВЖИНА (str)
+ Витягти підрядок із заданого рядка:
  * SUBSTRING(рядок, зсув, #символ_повернено)
+ Сліпа ін’єкція на основі часу:
  * BENCHMARK і SLEEP BENCHMARK(#ofcycles,action_to_be_performed) Функцію бенчмарка можна використовувати для виконання атак із визначенням часу, коли сліпе впровадження логічних значень не дає жодних результатів. Побачити. SLEEP() (MySQL > 5.0.x) для альтернативного тестування.















